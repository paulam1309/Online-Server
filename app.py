# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10m7g8FFbB9-EHKAqBO75tViYmgDGnoaO

# **FastAPI (Servicio de Inferencia)**

Es el endpoint encargado de recibir ventanas, armar el dataframe con el orden de schema-json, llama al pipeline de SVM + Calibrador y devuelve predict_label + confianza.

LLama a su vez a policy engine en caso de que la confianza baje del 70%

**LIBRERÍAS**
"""

import os, json, joblib
import pandas as pd
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from starlette.middleware.cors import CORSMiddleware
import time
import policy  # importa el motor de reglas
import psycopg2
from psycopg2 import sql
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict

"""**CONEXIÓN CON CON LA BASE DE DATOS**"""

DATABASE_URL = os.environ["DATABASE_URL"]  # definida en Render
CONN = psycopg2.connect(DATABASE_URL)
CONN.autocommit = True

"""**CARGA DE ARCHIVOS NECESARIOS**"""

MODEL_PATH = os.getenv("MODEL_PATH", "models/svm_calibrado.pkl")
SCHEMA_PATH = os.getenv("SCHEMA_PATH", "processing/schema.json")

try:
    MODEL = joblib.load(MODEL_PATH)  # pipeline: scaler → SVM → calibración
except Exception as e:
    raise RuntimeError(f"No pude cargar el modelo en {MODEL_PATH}: {e}")

try:
    with open(SCHEMA_PATH, "r", encoding="utf-8") as f:
        SCHEMA = json.load(f)
    FEATURES = SCHEMA["features"]
    CLASSES = getattr(MODEL, "classes_", SCHEMA.get("classes", []))
except Exception as e:
    raise RuntimeError(f"No pude cargar el schema en {SCHEMA_PATH}: {e}")

"""**Configuraciones para conexión remota**"""

app = FastAPI(title="HAR Online – Inference")

# CORS para que la app de Flutter pueda llamar al API
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

# Iniciar sesión
class SessionStart(BaseModel):
    id_usuario: int
    session_id: int

class Window(BaseModel):
    id_usuario: int
    session_id: int
    start_time: datetime
    end_time: datetime
    sample_rate_hz: Optional[float] = None
    sample_count: Optional[int] = None
    features: Dict[str, float]

# Payload mínimo para marcar etiquetas
class LabelIn(BaseModel):
    id_usuario: int
    session_id: int
    start_ts: datetime
    end_ts: datetime
    label: str
    reason: str | None = "manual"

"""**Configuración de opciones de tiempo**"""

def _as_utc(dt: datetime) -> datetime:
    if dt.tzinfo is None:
        return dt.replace(tzinfo=timezone.utc)
    return dt.astimezone(timezone.utc)

def _epoch(dt: datetime) -> float:
    return _as_utc(dt).timestamp()

"""**Configuración para insertar cada ventana en /ingest**"""

# Commented out IPython magic to ensure Python compatibility.
TABLE = "windows"
USER_COL = "id_usuario"

def insert_window_pg(
    session_id: int,
    id_usuario: int,
    start_time: datetime,
    end_time: datetime,
    features_row: dict,
    pred_label: str,
    conf: float,
    sample_rate_hz: float | None = None,
    sample_count: int | None = None,
    start_index: int | None = None,
    end_index: int | None = None,
    n_muestras: int | None = None,
):
    st = _as_utc(start_time)
    et = _as_utc(end_time)
    feats_json = json.dumps({k: features_row[k] for k in FEATURES})

    with CONN.cursor() as cur:
        cur.execute(sql.SQL("""
            INSERT INTO {tbl} (
              {user}, session_id, received_at,
              start_time, end_time,
              sample_rate_hz, sample_count,
              start_index, end_index, n_muestras,
              activity, etiqueta, features
            )
            VALUES (
#               %s, %s, now(),
#               %s, %s,
#               %s, %s,
#               %s, %s, %s,
#               %s, NULL, %s::jsonb
            )
        """).format(
            tbl=sql.Identifier(TABLE),
            user=sql.Identifier(USER_COL),
        ), [
            int(id_usuario), int(session_id),
            st, et,
            sample_rate_hz, sample_count,
            start_index, end_index, n_muestras,
            str(pred_label), feats_json
        ])

"""**Gets**


Realiza un monitoreo para corroborar que el servidor esté en producción y haya cargado los archivos.
"""

@app.get("/health")
def health():
    return {"ok": True, "model": os.path.basename(MODEL_PATH), "n_features": len(FEATURES)}

@app.get("/schema")
def schema():
    return {"features": FEATURES, "classes": list(map(str, CLASSES))}

"""**Endpoint para iniciar sesión**"""

@app.post("/session/start")
def session_start(s: SessionStart):
    """
    Marca la sesión como recién iniciada y responde con una solicitud de etiqueta inmediata.
    """
    # 1) Resetear estado y marcar “pregunta inicial” pendiente
    sid_key = str(s.session_id)          # policy usa string como clave
    policy.start_session(sid_key, now_ts=time.time())
    # 2) Contabilizar la solicitud (cooldown/presupuesto) y consumir el flag
    policy.mark_asked(sid_key, now_ts=time.time())
    policy.clear_initial(sid_key)

    return {
        "ask_label": True,
        "ask_reason": "initial",
        "suggested_duration_s": 60
    }

"""**Endpoint de Ingest**


Se construye del Dataframe y se pasa al .pkl para obtener pred_label + confianza
"""

@app.post("/ingest")
def ingest(w: Window):
    # 1) Validar features contra schema
    row, missing = {}, []
    for k in FEATURES:
        v = w.features.get(k)
        if v is None: missing.append(k)
        row[k] = v
    if missing:
        raise HTTPException(status_code=400, detail={"missing_features": missing})

    # 2) Predicción
    X = pd.DataFrame([row])
    try:
        proba = MODEL.predict_proba(X)[0]
    except Exception as e:
        raise HTTPException(500, f"Error en predict_proba: {e}")

    idx = int(proba.argmax())
    conf = float(proba[idx])
    pred_label = CLASSES[idx] if len(CLASSES) else idx

    # 3) Persistir ventana
    insert_window_pg(
        session_id=w.session_id,
        id_usuario=w.id_usuario,
        start_time=w.start_time,
        end_time=w.end_time,
        features_row=row,
        pred_label=str(pred_label),
        conf=conf,
        sample_rate_hz=w.sample_rate_hz,
        sample_count=w.sample_count,
        start_index=None, end_index=None, n_muestras=None,
    )

    # 4) Policy (usa epoch del centro)
    center_epoch = (_epoch(w.start_time) + _epoch(w.end_time)) / 2.0
    sid_key = str(w.session_id)
    ask, reason = policy.should_ask(sid_key, conf, now_ts=center_epoch)
    if ask:
        policy.mark_asked(sid_key, now_ts=center_epoch)

    return {
        "pred_label": str(pred_label),
        "confianza": conf,
        "ask_label": ask,
        "ask_reason": reason,
        "classes": list(map(str, CLASSES)),
    }

"""**Endpoint para registrar que el usuario respondió una etiqueta**"""

@app.post("/label")
def label_endpoint(p: LabelIn):
    sid_key = str(p.session_id)

    # 1) Definir intervalo
    if p.start_ts and p.end_ts:
        s = _as_utc(p.start_ts); e = _as_utc(p.end_ts)
    else:
        dur = int(p.duration_s or 60)
        e = datetime.now(timezone.utc)
        s = e - timedelta(seconds=dur)

    with CONN.cursor() as cur:
        # 2) Auditoría en intervalos_label
        cur.execute("""
            INSERT INTO intervalos_label
              (session_id, start_ts, end_ts, label, reason, user_id, created_at)
            VALUES
              (%s, %s, %s, %s, %s, %s, now())
        """, (int(p.session_id), s, e, str(p.label), p.reason or "manual", int(p.id_usuario)))

        # 3) Alinear por centro
        cur.execute("""
            UPDATE windows
               SET etiqueta = %s
             WHERE id_usuario = %s
               AND session_id = %s
               AND (start_time + (end_time - start_time)/2)
                   BETWEEN %s AND %s
        """, (str(p.label), int(p.id_usuario), int(p.session_id), s, e))
        matched = cur.rowcount

    policy.mark_labeled(sid_key, now_ts=_epoch(e))
    return {"ok": True, "matched_windows": int(matched),
            "interval": {"start": s.isoformat(), "end": e.isoformat()}}