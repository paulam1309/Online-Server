# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10m7g8FFbB9-EHKAqBO75tViYmgDGnoaO

# **FastAPI (Servicio de Inferencia)**

Es el endpoint encargado de recibir ventanas, armar el dataframe con el orden de schema-json, llama al pipeline de SVM + Calibrador y devuelve predict_label + confianza.

LLama a su vez a policy engine en caso de que la confianza baje del 70%

**LIBRERÍAS**
"""

import os, json, joblib
import pandas as pd
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from starlette.middleware.cors import CORSMiddleware
import policy  # importa el motor de reglas
import psycopg2
from psycopg2 import sql
from psycopg2.extras import RealDictCursor
from datetime import datetime, timezone
from typing import Optional, Dict, Any, List
# arriba, junto a tus imports

"""**CONEXIÓN CON CON LA BASE DE DATOS**"""

DATABASE_URL = os.environ["DATABASE_URL"]
def get_conn():
    return psycopg2.connect(DATABASE_URL, cursor_factory=RealDictCursor)

"""**CARGA DE ARCHIVOS NECESARIOS**"""

MODEL_PATH = os.getenv("MODEL_PATH", "models/svm_calibrado.pkl")
SCHEMA_PATH = os.getenv("SCHEMA_PATH", "processing/schema.json")

try:
    MODEL = joblib.load(MODEL_PATH)  # pipeline: scaler → SVM → calibración
except Exception as e:
    raise RuntimeError(f"No pude cargar el modelo en {MODEL_PATH}: {e}")

try:
    with open(SCHEMA_PATH, "r", encoding="utf-8") as f:
        SCHEMA = json.load(f)
    FEATURES = SCHEMA["features"]
    CLASSES = getattr(MODEL, "classes_", SCHEMA.get("classes", []))
except Exception as e:
    raise RuntimeError(f"No pude cargar el schema en {SCHEMA_PATH}: {e}")

"""**Configuraciones para conexión remota**"""

app = FastAPI(title="HAR Online – Inference")

# CORS para que la app de Flutter pueda llamar al API
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

"""**Helpers**"""

# --- helpers ---
def _df_from_window_row(row: Dict[str, Any]) -> pd.DataFrame:
    if row.get("features"):
        feats: Dict[str, Any] = row["features"]
        data = {f: feats.get(f, 0.0) for f in FEATURES}
    else:
        data = {f: row.get(f, 0.0) for f in FEATURES}
    return pd.DataFrame([data], columns=FEATURES)

def _center_ts(row: Dict[str, Any]) -> float:
    st, et = row["start_time"], row["end_time"]
    c = st + (et - st) / 2
    if c.tzinfo is None:
        c = c.replace(tzinfo=timezone.utc)
    return c.timestamp()

"""**Models**"""

class PredictByWindowReq(BaseModel):
    id: int = Field(..., description="PK de windows")

class LabelReq(BaseModel):
    id_usuario: int
    session_id: int
    start_ts: datetime
    end_ts: datetime
    label: str
    reason: Optional[str] = None

class MarkReq(BaseModel):
    id_usuario: int
    session_id: int
    when: Optional[datetime] = None

class SLPredictReq(BaseModel):
    id: int
    actividad: str
    precision: Optional[float] = None

"""**Gets**


Realiza un monitoreo para corroborar que el servidor esté en producción y haya cargado los archivos.
"""

@app.get("/health")
def health():
    return {"ok": True, "model": os.path.basename(MODEL_PATH), "n_features": len(FEATURES)}

@app.get("/schema")
def schema():
    return {"features": FEATURES, "classes": list(map(str, CLASSES))}

"""**Endpoint de Ingest**


Se construye del Dataframe y se pasa al .pkl para obtener pred_label + confianza
"""

@app.post("/predict_by_window")
def predict_by_window(req: PredictByWindowReq):
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute("SELECT * FROM windows WHERE id = %s", (req.id,))
        row = cur.fetchone()
        if not row:
            raise HTTPException(404, f"id {req.id} no existe")

        X = _df_from_window_row(row)
        proba = MODEL.predict_proba(X)[0]
        i_top = int(proba.argmax())
        pred_label = str(CLASSES[i_top])
        confianza = float(proba[i_top])

        id_usuario = int(row["id_usuario"])
        session_id = int(row["session_id"])

        ask, reason = policy.should_ask(
            id_usuario, session_id, confianza, pred_label=pred_label, now_ts=_center_ts(row)
        )
        if ask:
            policy.mark_asked(id_usuario, session_id)

        cur.execute(
            "UPDATE windows SET pred_label=%s, confianza=%s WHERE id=%s",
            (pred_label, confianza, req.id),
        )
        conn.commit()

    return {
    "id": req.id,
    "pred_label": pred_label,
    "confianza": confianza,
    "ask_label": ask,
    "ask_reason": reason,
    "classes": list(map(str, CLASSES)),
  }

"""**Endpoint para registrar que el usuario respondió una etiqueta**"""

@app.post("/label")
def post_label(req: LabelReq):
    st = req.start_ts.astimezone(timezone.utc)
    et = req.end_ts.astimezone(timezone.utc)
    if et <= st:
        raise HTTPException(400, "end_ts debe ser > start_ts")

    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(
            """
            INSERT INTO intervalos_label (session_id, start_ts, end_ts, label, reason, created_at, id_usuario)
            VALUES (%s,%s,%s,%s,%s,NOW(),%s)
            RETURNING id
            """,
            (req.session_id, st, et, req.label, req.reason, req.id_usuario),
        )
        interval_id = cur.fetchone()["id"]

        cur.execute(
            """
            UPDATE windows
               SET etiqueta = %s
             WHERE id_usuario = %s
               AND session_id = %s
               AND start_time >= %s
               AND end_time   <= %s
            """,
            (req.label, req.id_usuario, req.session_id, st, et),
        )
        conn.commit()

    policy.mark_labeled(req.id_usuario, req.session_id)
    return {"ok": True, "interval_id": interval_id}

@app.post("/policy/asked")
def policy_mark_asked(req: MarkReq):
    policy.mark_asked(req.id_usuario, req.session_id, req.when.timestamp() if req.when else None)
    return {"ok": True}

@app.post("/policy/labeled")
def policy_mark_labeled(req: MarkReq):
    policy.mark_labeled(req.id_usuario, req.session_id, req.when.timestamp() if req.when else None)
    return {"ok": True}

"""**SL**"""

@app.post("/sl/predict")
def sl_predict(req: SLPredictReq):
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute("SELECT id FROM windows WHERE id = %s", (req.id,))
        if not cur.fetchone():
            raise HTTPException(404, f"id {req.id} no existe")

        cur.execute("UPDATE windows SET actividad=%s WHERE id=%s", (req.actividad, req.id))
        conn.commit()
    return {"ok": True, "id": req.id, "actividad": req.actividad}