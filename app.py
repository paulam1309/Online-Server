# -*- coding: utf-8 -*-
"""FastAPI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10m7g8FFbB9-EHKAqBO75tViYmgDGnoaO
"""

import os, json, joblib
import pandas as pd
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from starlette.middleware.cors import CORSMiddleware

# --- Carga artefactos al arrancar ---
MODEL_PATH = os.getenv("MODEL_PATH", "models/svm_calibrado.pkl")
SCHEMA_PATH = os.getenv("SCHEMA_PATH", "processing/schema.json")

try:
    MODEL = joblib.load(MODEL_PATH)  # pipeline: scaler → SVM → calibración
except Exception as e:
    raise RuntimeError(f"No pude cargar el modelo en {MODEL_PATH}: {e}")

try:
    with open(SCHEMA_PATH, "r", encoding="utf-8") as f:
        SCHEMA = json.load(f)
    FEATURES = SCHEMA["features"]
    CLASSES = getattr(MODEL, "classes_", SCHEMA.get("classes", []))
except Exception as e:
    raise RuntimeError(f"No pude cargar el schema en {SCHEMA_PATH}: {e}")

app = FastAPI(title="HAR Online – Inference")

# CORS para que tu app Flutter pueda llamar al API
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

class Window(BaseModel):
    device_id: str
    session_id: str
    ts_start: float
    ts_end: float
    features: dict  # {nombre_feature: valor}

@app.get("/health")
def health():
    return {"ok": True, "model": os.path.basename(MODEL_PATH), "n_features": len(FEATURES)}

@app.get("/schema")
def schema():
    return {"features": FEATURES, "classes": list(map(str, CLASSES))}

@app.post("/ingest")
def ingest(w: Window):
    # arma DataFrame en el orden exacto del schema
    row = {}
    missing = []
    for k in FEATURES:
        v = w.features.get(k, None)
        if v is None:
            missing.append(k)
        row[k] = v
    if missing:
        raise HTTPException(status_code=400, detail={"missing_features": missing})

    X = pd.DataFrame([row])  # DataFrame para mantener nombres de columnas
    try:
        proba = MODEL.predict_proba(X)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error en predict_proba: {e}")

    conf = float(proba.max(axis=1)[0])
    idx  = int(proba.argmax(axis=1)[0])
    label = CLASSES[idx] if len(CLASSES) else idx

    # En producción aquí guardarías (w, pred, conf) en BD
    return {
        "pred_label": str(label),
        "confianza": conf,
        "classes": list(map(str, CLASSES)),
    }