# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10m7g8FFbB9-EHKAqBO75tViYmgDGnoaO

# **FastAPI (Servicio de Inferencia)**

Es el endpoint encargado de recibir ventanas, armar el dataframe con el orden de schema-json, llama al pipeline de SVM + Calibrador y devuelve predict_label + confianza.

LLama a su vez a policy engine en caso de que la confianza baje del 70%

**LIBRERÍAS**
"""

import os, json, joblib
import pandas as pd
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from starlette.middleware.cors import CORSMiddleware
import time
import policy  # importa el motor de reglas

"""**CARGA DE ARCHIVOS NECESARIOS**"""

MODEL_PATH = os.getenv("MODEL_PATH", "models/svm_calibrado.pkl")
SCHEMA_PATH = os.getenv("SCHEMA_PATH", "processing/schema.json")

try:
    MODEL = joblib.load(MODEL_PATH)  # pipeline: scaler → SVM → calibración
except Exception as e:
    raise RuntimeError(f"No pude cargar el modelo en {MODEL_PATH}: {e}")

try:
    with open(SCHEMA_PATH, "r", encoding="utf-8") as f:
        SCHEMA = json.load(f)
    FEATURES = SCHEMA["features"]
    CLASSES = getattr(MODEL, "classes_", SCHEMA.get("classes", []))
except Exception as e:
    raise RuntimeError(f"No pude cargar el schema en {SCHEMA_PATH}: {e}")

"""**Configuraciones para conexión remota**"""

app = FastAPI(title="HAR Online – Inference")

# CORS para que la app de Flutter pueda llamar al API
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

# Iniciar sesión
class SessionStart(BaseModel):
    device_id: str
    session_id: str

class Window(BaseModel):
    device_id: str
    session_id: str
    ts_start: float
    ts_end: float
    features: dict  # {nombre_feature: valor}

# Payload mínimo para marcar etiquetas
class LabelIn(BaseModel):
    session_id: str
    label: str
    duration_s: int | None = 60   # aquí solo registramos; el aligner vendrá luego

"""**Gets**


Realiza un monitoreo para corroborar que el servidor esté en producción y haya cargado los archivos.
"""

@app.get("/health")
def health():
    return {"ok": True, "model": os.path.basename(MODEL_PATH), "n_features": len(FEATURES)}

@app.get("/schema")
def schema():
    return {"features": FEATURES, "classes": list(map(str, CLASSES))}

"""**Endpoint para iniciar sesión**"""

@app.post("/session/start")
def session_start(s: SessionStart):
    """
    Marca la sesión como recién iniciada y responde con una solicitud de etiqueta inmediata.
    """
    # 1) Resetear estado y marcar “pregunta inicial” pendiente
    policy.start_session(s.session_id, now_ts=time.time())
    # 2) Contabilizar la solicitud (cooldown/presupuesto) y consumir el flag
    policy.mark_asked(s.session_id, now_ts=time.time())
    policy.clear_initial(s.session_id)

    return {
        "ask_label": True,
        "ask_reason": "initial",
        "suggested_duration_s": 60
    }

"""**Endpoint de Ingest**


Se construye del Dataframe y se pasa al .pkl para obtener pred_label + confianza
"""

@app.post("/ingest")
def ingest(w: Window):
    # arma DataFrame en el orden exacto del schema
    row = {}
    missing = []
    for k in FEATURES:
        v = w.features.get(k, None)
        if v is None:
            missing.append(k)
        row[k] = v
    if missing:
        raise HTTPException(status_code=400, detail={"missing_features": missing})

    X = pd.DataFrame([row])  # DataFrame para mantener nombres de columnas
    try:
        proba = MODEL.predict_proba(X)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error en predict_proba: {e}")

    conf = float(proba.max(axis=1)[0])
    idx  = int(proba.argmax(axis=1)[0])
    label = CLASSES[idx] if len(CLASSES) else idx

    # --- Policy Engine ---
    center_ts = (w.ts_start + w.ts_end) / 2.0
    ask, reason = policy.should_ask(session_id=w.session_id, conf=conf, now_ts=center_ts)
    if ask:
        policy.mark_asked(w.session_id, now_ts=center_ts)

    # Variables  (ventana, pred, conf, ask, reason) para guardar en la BD

    return {
        "pred_label": str(label),
        "confianza": conf,
        "ask_label": ask,
        "ask_reason": reason,
        "classes": list(map(str, CLASSES)),

    }

"""**Endpoint para registrar que el usuario respondió una etiqueta**"""

@app.post("/label")
def label_endpoint(payload: LabelIn):
    # Aquí SOLO registramos el evento (keep-alive). El alineador por intervalos vendrá después.
    policy.mark_labeled(payload.session_id, now_ts=time.time())
    return {"ok": True}