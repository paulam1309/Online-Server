# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10m7g8FFbB9-EHKAqBO75tViYmgDGnoaO

# **FastAPI (Servicio de Inferencia)**

Es el endpoint encargado de recibir ventanas, armar el dataframe con el orden de schema-json, llama al pipeline de SVM + Calibrador y devuelve predict_label + confianza.

LLama a su vez a policy engine en caso de que la confianza baje del 70%

**LIBRERÍAS**
"""

import os, json, joblib
import pandas as pd
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from starlette.middleware.cors import CORSMiddleware
import time
import policy  # importa el motor de reglas
import psycopg2
from psycopg2 import sql

"""**CONEXIÓN CON CON LA BASE DE DATOS**"""

DATABASE_URL = os.environ["DATABASE_URL"]  # definida en Render
CONN = psycopg2.connect(DATABASE_URL)
CONN.autocommit = True

"""**CARGA DE ARCHIVOS NECESARIOS**"""

MODEL_PATH = os.getenv("MODEL_PATH", "models/svm_calibrado.pkl")
SCHEMA_PATH = os.getenv("SCHEMA_PATH", "processing/schema.json")

try:
    MODEL = joblib.load(MODEL_PATH)  # pipeline: scaler → SVM → calibración
except Exception as e:
    raise RuntimeError(f"No pude cargar el modelo en {MODEL_PATH}: {e}")

try:
    with open(SCHEMA_PATH, "r", encoding="utf-8") as f:
        SCHEMA = json.load(f)
    FEATURES = SCHEMA["features"]
    CLASSES = getattr(MODEL, "classes_", SCHEMA.get("classes", []))
except Exception as e:
    raise RuntimeError(f"No pude cargar el schema en {SCHEMA_PATH}: {e}")

"""**Configuración para insertar cada ventana en /ingest**"""

# Commented out IPython magic to ensure Python compatibility.
TABLE = "windows"
USER_COL = "id_usuario"

def insert_window_pg(
    session_id: str,
    device_id: str,
    ts_start: float,
    ts_end: float,
    features_row: dict,
    pred_label: str,
    conf: float,
    start_index: int | None = None,
    end_index: int | None = None,
    n_muestras: int | None = None,
    gold_label: str | None = None,
):
    feats_json = json.dumps({k: features_row[k] for k in FEATURES})
    with CONN.cursor() as cur:
        cur.execute(sql.SQL("""
            INSERT INTO {tbl} (
              {user}, session_id, received_at, start_time, end_time,
              start_index, end_index, n_muestras,
              activity, etiqueta, features
            )
            VALUES (
#               %s, %s, now(), to_timestamp(%s), to_timestamp(%s),
#               %s, %s, %s,
#               %s, %s, %s::jsonb
            )
        """).format(
            tbl=sql.Identifier("windows"),
            user=sql.Identifier("id_usuario"),
        ), [
            device_id, session_id,
            float(ts_start), float(ts_end),
            start_index, end_index, n_muestras,
            str(pred_label), gold_label, feats_json
        ])

"""**Configuraciones para conexión remota**"""

app = FastAPI(title="HAR Online – Inference")

# CORS para que la app de Flutter pueda llamar al API
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

# Iniciar sesión
class SessionStart(BaseModel):
    device_id: str
    session_id: str

class Window(BaseModel):
    device_id: str
    session_id: str
    ts_start: float
    ts_end: float
    features: dict  # {nombre_feature: valor}

# Payload mínimo para marcar etiquetas
class LabelIn(BaseModel):
    session_id: str
    label: str
    duration_s: int | None = 60   # aquí solo registramos; el aligner vendrá luego

"""**Gets**


Realiza un monitoreo para corroborar que el servidor esté en producción y haya cargado los archivos.
"""

@app.get("/health")
def health():
    return {"ok": True, "model": os.path.basename(MODEL_PATH), "n_features": len(FEATURES)}

@app.get("/schema")
def schema():
    return {"features": FEATURES, "classes": list(map(str, CLASSES))}

"""**Endpoint para iniciar sesión**"""

@app.post("/session/start")
def session_start(s: SessionStart):
    """
    Marca la sesión como recién iniciada y responde con una solicitud de etiqueta inmediata.
    """
    # 1) Resetear estado y marcar “pregunta inicial” pendiente
    policy.start_session(s.session_id, now_ts=time.time())
    # 2) Contabilizar la solicitud (cooldown/presupuesto) y consumir el flag
    policy.mark_asked(s.session_id, now_ts=time.time())
    policy.clear_initial(s.session_id)

    return {
        "ask_label": True,
        "ask_reason": "initial",
        "suggested_duration_s": 60
    }

"""**Endpoint de Ingest**


Se construye del Dataframe y se pasa al .pkl para obtener pred_label + confianza
"""

@app.post("/ingest")
def ingest(w: Window):
    # arma DataFrame en el orden exacto del schema
    row = {}
    missing = []
    for k in FEATURES:
        v = w.features.get(k, None)
        if v is None:
            missing.append(k)
        row[k] = v
    if missing:
        raise HTTPException(status_code=400, detail={"missing_features": missing})

    X = pd.DataFrame([row])  # DataFrame para mantener nombres de columnas
    try:
        proba = MODEL.predict_proba(X)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error en predict_proba: {e}")

    conf = float(proba.max(axis=1)[0])
    idx  = int(proba.argmax(axis=1)[0])
    label = CLASSES[idx] if len(CLASSES) else idx

    #--- Insertar en la BD---
    insert_window_pg(
    session_id=w.session_id,
    device_id=w.device_id,      # se guarda en id_usuario
    ts_start=float(w.ts_start),
    ts_end=float(w.ts_end),
    features_row=row,
    pred_label=str(label),
    conf=float(conf),
    start_index=None, end_index=None, n_muestras=None,
    gold_label=None
    )

    # --- Policy Engine ---
    center_ts = (w.ts_start + w.ts_end) / 2.0
    ask, reason = policy.should_ask(session_id=w.session_id, conf=conf, now_ts=center_ts)
    if ask:
        policy.mark_asked(w.session_id, now_ts=center_ts)

    # Variables  (ventana, pred, conf, ask, reason) para guardar en la BD
    return {
        "pred_label": str(label),
        "confianza": conf,
        "ask_label": ask,
        "ask_reason": reason,
        "classes": list(map(str, CLASSES)),

    }

"""**Endpoint para registrar que el usuario respondió una etiqueta**"""

@app.post("/label")
def label_endpoint(payload: LabelIn):
    policy.mark_labeled(payload.session_id, now_ts=time.time())

    end_ts = float(time.time())
    dur = float(payload.duration_s or 60)
    start_ts = end_ts - dur

    with CONN.cursor() as cur:
        # 1) auditoría del intervalo
        cur.execute("""
          INSERT INTO label_intervals (session_id, start_ts, end_ts, label, reason)
          VALUES (%s, to_timestamp(%s), to_timestamp(%s), %s, %s)
        """, (payload.session_id, start_ts, end_ts, str(payload.label), "manual"))

        # 2) aplicar etiqueta por "centro" de la ventana
        cur.execute("""
          UPDATE windows
             SET etiqueta = %s
           WHERE session_id = %s
             AND (start_time + (end_time - start_time)/2)
                 BETWEEN to_timestamp(%s) AND to_timestamp(%s)
        """, (str(payload.label), payload.session_id, start_ts, end_ts))
        matched = cur.rowcount

    return {
        "ok": True,
        "matched_windows": int(matched),
        "interval": {"start": start_ts, "end": end_ts}
    }