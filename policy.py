# -*- coding: utf-8 -*-
"""Policy_Engine.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e5OalvZXveVZpPFkhWe7p-2lYnUKeZ0Y

# **POLICY ENGINE**

Motor de reglas encargado de decir cuando solicitar etiqueta al usuario

**Librerías**
"""

import time
from dataclasses import dataclass, field
from collections import deque

"""**Variables para definir las reglas**"""

MIN_CONF = 0.70          # umbral de confianza
N_CONSEC = 3             # ventanas consecutivas por debajo del umbral
COOLDOWN_S = 60          # no preguntar de nuevo antes de 60 s
MAX_ASKS_PER_H = 4       # máximo 4 solicitudes por hora
KEEP_ALIVE_S = 5 * 60    # pedir etiqueta si no hemos recibido una en 5 min

"""**Estado por sesión**"""

@dataclass
class SessionState:
    last_conf: deque = field(default_factory=lambda: deque(maxlen=N_CONSEC))
    last_ask_ts: float = 0.0
    asks_in_hour: deque = field(default_factory=deque)  # timestamps de las últimas solicitudes
    last_label_ts: float = 0.0
    initial_ask_pending: bool = False    # ← Solicitar etiqueta al iniciar

STATE: dict[str, SessionState] = {}

"""**Función para iniciar sesión y preguntar etiqueta inicial**"""

def start_session(session_id: str, now_ts: float | None = None) -> None:
    """Crea/limpia el estado y marca que se debe preguntar inmediatamente."""
    st = SessionState()
    st.initial_ask_pending = True
    STATE[session_id] = st

"""**Función para asegurarse que solo pregunte etiqueta inicial en start_session**"""

def clear_initial(session_id: str) -> None:
    st = STATE.setdefault(session_id, SessionState())
    st.initial_ask_pending = False

"""**Funciones para el motor de reglas**"""

def _now(ts: float | None = None) -> float:
    return float(ts if ts is not None else time.time())

def _prune_hour(st: SessionState, now: float) -> None:
    """Deja solo las solicitudes de los últimos 3600 s."""
    one_hour_ago = now - 3600.0
    while st.asks_in_hour and st.asks_in_hour[0] < one_hour_ago:
        st.asks_in_hour.popleft()

def record_conf(session_id: str, conf: float) -> SessionState:
    """Guarda la última confianza (para contar consecutivas)."""
    st = STATE.setdefault(session_id, SessionState())
    st.last_conf.append(conf)
    return st

def should_ask(session_id: str, conf: float, now_ts: float | None = None) -> tuple[bool, str]:
    """
    Devuelve (ask, reason) según las reglas:
      - cooldown
      - presupuesto/hora
      - keep-alive
      - baja confianza sostenida
    """
    now = _now(now_ts)
    st = record_conf(session_id, conf)

    # --- PRIORIDAD: al iniciar la sesión, preguntar etiqueta ---
    if st.initial_ask_pending:
        st.initial_ask_pending = False
        return True, "initial"

    # Cooldown
    if now - st.last_ask_ts < COOLDOWN_S:
        return False, "cooldown"

    # Presupuesto por hora
    _prune_hour(st, now)
    if len(st.asks_in_hour) >= MAX_ASKS_PER_H:
        return False, "budget"

    # Keep-alive (no hemos recibido etiqueta recientemente)
    if st.last_label_ts == 0.0 or (now - st.last_label_ts) >= KEEP_ALIVE_S:
        return True, "keep_alive"

    # Baja confianza sostenida
    if len(st.last_conf) == N_CONSEC and all(c < MIN_CONF for c in st.last_conf):
        return True, "uncertainty"

    return False, "ok"

def mark_asked(session_id: str, now_ts: float | None = None) -> None:
    """Registra que se hizo la pregunta (para cooldown y presupuesto)."""
    now = _now(now_ts)
    st = STATE.setdefault(session_id, SessionState())
    st.last_ask_ts = now
    _prune_hour(st, now)
    st.asks_in_hour.append(now)

def mark_labeled(session_id: str, now_ts: float | None = None) -> None:
    """Registra que el usuario dio una etiqueta (resetea keep-alive)."""
    st = STATE.setdefault(session_id, SessionState())
    st.last_label_ts = _now(now_ts)