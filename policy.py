# -*- coding: utf-8 -*-
"""policy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e5OalvZXveVZpPFkhWe7p-2lYnUKeZ0Y

# **POLICY ENGINE**

Motor de reglas encargado de decir cuando solicitar etiqueta al usuario

**Librerías**
"""

import time
from dataclasses import dataclass, field
from collections import deque
from typing import Deque, Tuple, Dict, Optional

"""**Variables para definir las reglas**"""

MIN_CONF = 0.97
N_CONSEC = 3
COOLDOWN_S = 15
MAX_ASKS_PER_H = 10
KEEP_ALIVE_S = 10

# Cambio de label
SWITCH_MIN_CONF = 0.85
SWITCH_N_CONSEC = 2

"""**Estado por sesión**"""

@dataclass
class SessionState:
    last_label_ts: float = 0.0
    last_ask_ts: float = 0.0
    asks_in_hour: Deque[float] = field(default_factory=lambda: deque(maxlen=64))
    last_conf: Deque[float] = field(default_factory=lambda: deque(maxlen=N_CONSEC))

    # tracking de cambio de actividad
    last_pred_label: str | None = None

     # Swicth: seguimiento del candidato de cambio
    change_label: str | None = None
    change_run: int = 0

# clave: (id_usuario, session_id)
STATE: Dict[Tuple[int, int], SessionState] = {}

"""**Funciones para el motor de reglas**"""

def _key(uid: int, sid: int) -> Tuple[int, int]:
    return int(uid), int(sid)

def _now(ts: float | None = None) -> float:
    return float(ts if ts is not None else time.time())

def _prune_hour(st: SessionState, now: float) -> None:
    one_hour_ago = now - 3600.0
    while st.asks_in_hour and st.asks_in_hour[0] < one_hour_ago:
        st.asks_in_hour.popleft()

def record_conf(uid: int, sid: int, conf: float) -> SessionState:
    st = STATE.setdefault(_key(uid, sid), SessionState())
    st.last_conf.append(conf)
    return st

def record_pred(uid: int, sid: int, label: str, conf: float) -> SessionState:
    st = STATE.setdefault(_key(uid, sid), SessionState())

    if conf >= SWITCH_MIN_CONF:
        if st.change_label == label:
            # seguimos viendo el mismo "nuevo" label
            st.change_run += 1
        elif st.last_pred_label is not None and label != st.last_pred_label:
            # detectamos un cambio de label: comenzamos corrida nueva
            st.change_label = label
            st.change_run = 1
        else:
            # sin cambio o sin suficiente confianza: resetea corrida
            st.change_label = None
            st.change_run = 0

    st.last_pred_label = label
    return st

def should_ask(uid: int, sid: int, conf: float, pred_label: str | None = None,
               now_ts: float | None = None) -> tuple[bool, str]:
    now = _now(now_ts)
    st = record_conf(uid, sid, conf)
    if pred_label is not None:
        st = record_pred(uid, sid, pred_label, conf)

    # cooldown
    if now - st.last_ask_ts < COOLDOWN_S:
        return False, "cooldown"

    _prune_hour(st, now)
    if len(st.asks_in_hour) >= MAX_ASKS_PER_H:
        return False, "budget"

    # cambio de actividad: si llevamos N ventanas seguidas con el nuevo label
    if st.change_run >= SWITCH_N_CONSEC:
        return True, "switch"

    # keep-alive
    if st.last_label_ts == 0.0 or (now - st.last_label_ts) >= KEEP_ALIVE_S:
        return True, "keep_alive"

    # baja confianza sostenida
    if len(st.last_conf) == N_CONSEC and all(c < MIN_CONF for c in st.last_conf):
        return True, "uncertainty"

    return False, "ok"

def mark_asked(uid: int, sid: int, now_ts: float | None = None) -> None:
    now = _now(now_ts)
    st = STATE.setdefault(_key(uid, sid), SessionState())
    st.last_ask_ts = now
    _prune_hour(st, now)
    st.asks_in_hour.append(now)
    # resetear la corrida de cambio
    st.change_label = None
    st.change_run = 0

def mark_labeled(uid: int, sid: int, now_ts: float | None = None) -> None:
    st = STATE.setdefault(_key(uid, sid), SessionState())
    st.last_label_ts = _now(now_ts)